---
layout: page
title:	Tail_Call(尾递归)
category: blog
description: 
---
# Preface
尾递归(tail call), 也叫尾调用, 常规的递归(self call)函数有一个问题是: 无法估量其调用栈(每一次递归都会增一次栈开销). 而尾递归不同, 它可以不在调用栈上面添加一个新的堆栈帧——而是更新它，如同迭代一般。尾递归因而具有两个特征([尾调用]):

	1. 调用自身函数(Self-called)；
	2. 计算仅占用常量栈空间(Stack Space)。//要实现这一点, 每一次递归调用时, 之前的计算结果都都可以丢掉了(即不用再保存在栈中了)

# 实例
要实现这两点, 算法必须满足: `f(n, t) = f(n-1, f_tmp(n, t))`. 

1. 第一次调用f(n, t): 经过中间计算f_tmp(n, t)后
2. 第二次调用f(n-1, f_tmp(n,t) ), 上一次的中间计算无关了, 没有必要再做栈保存了.

	// 这是一个求和的尾递归的示例. 当然, 这只是示例, 对于这个特定的问题, 更高效的是迭代, 比迭代更高效的是(n+1)*n/2
	function f(n, sum = 0){
		if(n <= 1){
			return n+sum;
		}
		return f(n-1, n+sum);
	}

## 透过弹跳床 
然而，由于很多 Scheme 的编译器使用 C 作为中间目标语言，问题变成如何在 C 里在不让栈向上长的前提下实现尾部递归（假设 C 的编译器不优化尾部调用）。很多实现透过一种叫做弹跳床的装置，也就是一块不断进行函数调用的代码。所有进入函数的过程都透过这个弹跳床。当一个个函数需要尾部调用另一个函数时，它不是直接调用该函数，而是将该函数的位置、该调用使用的参数等等返回给弹跳床。这样就可以确保 C 的栈不会不会向上长而可以让循环继续运行。


# Reference
[尾调用]

[尾调用]: http://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8
